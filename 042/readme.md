# learning git branch

## 循序渐进介绍 git 主要命令

### git commit

### git branch

### git merge

### git rebase

> rebase 就是将一个分支的提交记录迁移到另外一个分支，为的是创造更线性的提交，例如：

```bash
#假设当前在 bugFix 分支下
#把 `bugFix` 分支到 `bugFix`分支和 `main` 分支分叉的地方的所有 commit，复制到 main 分支下。
git rebase main

#rebase bugFix 到 main
git rebase main bugFix
```

## git 的超棒特性

### 分离HEAD

### 相对引用（^）

- 使用 `^` 向上移动一个提交记录
- 使用 `~<num>` 向上移动多个提交记录

### 相对引用（~<num>）

```bash
git branch -f main c6
git branch -f main bugFix~3
```

### 撤销变更

> `reset` 和 `revert` 都是修改当前分支。
>
> - git revert pushed 代表创建一个新的commit，这个 commit 指向 pushed，并将这个 commit 增加到当前分支的下面
> - git revert pushed^ 代表创建一个新的 commit，这个 commit 指向 pushed^，并将这个 commit 增加到当前分支的下面

- git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。`git reset` 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！
- git revert 为了撤销更改并**分享**给别人，我们需要使用 `git revert`。`revert` 将创建一个新的提交，并将新的提交添加在 `revert` 的后面。这样用户就可以看到我们之前的提交了。

## 自由修改提交树

### git cherry-pick

> `cherry-pick` 就是将我们所需要的提交复制到 `HEAD` 的下面。比如 `git cherry-pick c3 c4 c7` 这条命令就会得到一个 `HEAD -> c3 -> c4 -> c7` 的 commit 记录。

```bash
git cherry-pick c3 c4 c7
```

### 交互式的 rebase

> 交互式 rebase 指的是使用带参数 `--interactive` 的 rebase 命令, 简写为 `-i`
>
> 使用 `git rebase -i ${pointer}`

```bash
git rebase -i overHere
```

## Git 技术、技巧与贴士大集合

### 只取一个提交记录

> 来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。
>
> 这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！
>
> 最后就差把 `bugFix` 分支里的工作合并回 `main` 分支了。你可以选择通过 fast-forward 快速合并到 `main` 分支上，但这样的话 `main` 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……
>
> 实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用
>
> - `git rebase -i`
> - `git cherry-pick`
>
> 来达到目的。

```bash
git checkout main

git cherry-pick c4
```

### 提交的技巧#1

> 接下来这种情况也是很常见的：你之前在 `newImage` 分支上进行了一次提交，然后又基于它创建了 `caption` 分支，然后又提交了一次。
>
> 此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 `newImage` 中图片的分辨率，尽管那个提交记录并不是最新的了。
>
> 我们可以通过下面的方法来克服困难：
>
> 1. 先用 `git rebase -i` 将提交重新排序，然后把我们想要修改的提交记录挪到最前
> 2. 然后用 `git commit --amend` 来进行一些小修改
> 3. 接着再用 `git rebase -i` 来将他们调回原来的顺序
> 4. 最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦

### git tags

> 相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。
>
> 你可能会问了：有没有什么可以*永远*指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？
>
> 当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。
>
> 更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。

```bash
# 使用v0标签标记c1
git tag v0 c1
# 使用v1标签标记c2
git tag v1 c2

git checkout v1
```

### git describe

> 由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来**描述**离你最近的锚点（也就是标签），它就是 `git describe`！
>
> Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 `git bisect`（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。

## 远程仓库

### 远程分支

> `git clone` 之后，我们的本地仓库多了一个名为 `o/main` 的分支, 这种类型的分支就叫**远程**分支。由于远程分支的特性导致其拥有一些特殊属性。
>
> 远程分支反映了远程仓库(在你上次和它通信时)的**状态**。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.
>
> 远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。
>
> 你可能想问这些远程分支的前面的 `o/` 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:
>
>  `<remote name>/<branch name>`
>
> 因此，如果你看到一个名为 `o/main` 的分支，那么这个分支就叫 `main`，远程仓库的名称就是 `o`。

### git fetch

>`git fetch` 完成了仅有的但是很重要的两步:
>
>1. 从远程仓库下载本地仓库中缺失的提交记录
>2. 更新远程分支指针(如 `o/main`)
>
>`git fetch` 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。
>
>`git fetch` 并不会改变你本地仓库的状态。它不会更新你的 `main` 分支，也不会修改你磁盘上的文件。
>
>理解这一点很重要，因为许多开发人员误以为执行了 `git fetch` 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是**并没有**修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令
>
>所以, 你可以将 `git fetch` 的理解为单纯的下载操作。

### git pull

> 实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 `git pull`。

### git push

> `git push` 负责将**你的**变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 `git push` 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！

### 偏离的工作

> 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。
>
> 这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？
>
> 因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。
>
> 我们可以通过：
>
> - git fetch; git rebase;
> - git fetch; git merge;
>
> 来实现 push。
>
> 也可以通过 `git pull --rebase`

### pull request

> 远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.
>
> 你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.
>
> 现在我们需要新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.

```bash
#创建新的分支
git branch feature
#将本地分支恢复到远程分支一样的状态
git reset main^
#提交 pull request
git checkout feature
git push
```



























